import numpy as np
import pandas as pd
from scipy.spatial.transform import Rotation as R

def generate_nodes_around_lead(MRI_shift,
                               Nx, Nz_p, Nz_n,
                               dx, dz, xmin, z0, 
                               n_dirs, 
                               produce_centers=True,
                               alpha=None, gamma=None, order='x_first',
                               test=True,
                               input_dict = 'GUI_inp_dict.py',
                               target_path = 'Neuron_model_arrays/',
                               pattern_path= 'Neuron_model_arrays/default_pattern.csv'):
    
    """
    Generated a grid of nodes surrounding the lead cylindrically, in a system
    of coordinates (S) attached to the lead (center at the implantation 
    location, z+ at the direction of the lead tip toward the skull). A 2D grid 
    will be generated in x-z surface. Extra surfaces will be generated by 
    revolving the seeding surface along the z-direction with uniform angular
    seperation. 
    
    elementary arguments:
    =====================
    input_dict:      path to the input dictionary
    target_path:     save directort
    pattern_path:    path to the pattern that encapsulates the axon model nodes
    produce_centers: if true, an extra csv file containing the location of the 
                     centeral points in axons will be generated. These central 
                     points may or may not correspond to nodes of Ranvier 
                     (depending on the model and the length of the axon.)
    
    Geometrical inputs:
    ===================
    Nx:    number of seeds in x+ and x- direction
    Nz_p:  number of seeds in z+ direction (starts at the implantation level)
    Nz_n:  number of seeds in z- direction (starts at the implantation level)
    dx:    distance between seeds in x direction
    dy:    distance between seeds in y direction
    xmin:  minimum seeding distance lateral to the lead (in S coordinates)
    z0:    seeding starting level from the tip of the lead upward in S coordinates (mm)
    n_dirs:number of directions for VTA calculations. `n_dir` surfaces with a
           uniform angular seperation and the same seeding pattern will be placed
           around the lead. E.g., 1 corresponds to one surface, faced toward the 
           y-axis in (S coordinate system); 3 corresponds to three surfaces, one 
           faced toward the y-axis and the other two each with 60 degree seperation
           from each other. In general the angle between the planes is `180/n_dirs`.
           
    advanced inputs:
    ================
    In S coordinates, seeding points are in x-z plane and the axon nodes are
    place perpendicular to this plane, i.e. y direction. It's however possible
    to rotate the axons such that they are not necessarily in y-direction. To
    do so, one can specify rotation angles `alpha` and `gamma`, around the x
    and z axis, respectively. Note that since the axons are along the y-axis
    at first, a rotation along y doesn't make any difference. This will not 
    impose any limitation though. All possible directions can be specified by
    two directions. 
    
    In a spherical coordiante system that shares the same x,y, z axes with S 
    coordinates system we have:
    
    alpha = theta - 90 
    gamma = phi - 90
    
    Look at here for the definition of the (theta, phi) in spherical
    coordinates (physics convention):
        
        https://en.wikipedia.org/wiki/File:3D_Spherical.svg

    alpha: rotation along the x direction (in degree)
    gamma: rotation along the y direction (in degree)
    order: `x_first` will first rotate along the x and the z (default). The 
            alternative is `z_first`
    
    
    output:
    =======
    nodes: an array which contains the (x,y,z) of all the nodes on the grid.
           Since each node can be fully specified by its direction_id, seeding
           index in x and z, and its location along the axon, these (x,y,z) 
           coordinates are augmented by a 4-tuple to address the index of the
           node. Each entry thus has a form of (dir_id, i, j, k, x,y,z) with
           `i, j`, and `k` standing for the index in x,z, and y (on the axon)
           and`dir_id` the direction id. `i,j` start from the least value of 
           corresponding x,z seeding point.
           
    axons: an array, almost with the same structure as the nodes, except that 
           the coordinates are averaged alongside the axon (`k` direction) for
           each index `(dir_id, i,j)`. 
    """
    
    import importlib.util
    spec = importlib.util.spec_from_file_location("d",input_dict)
    foo = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(foo)
    d = foo.d
    
    ## Constructing the S coordinate system
    origin = np.array([d['Implantation_coordinate_X'], 
                       d['Implantation_coordinate_Y'],
                       d['Implantation_coordinate_Z']])

    # z-direction
    zhat = np.array([d['Second_coordinate_X']-d['Implantation_coordinate_X'],
                     d['Second_coordinate_Y']-d['Implantation_coordinate_Y'],
                     d['Second_coordinate_Z']-d['Implantation_coordinate_Z']])
    zhat /= np.linalg.norm(zhat)

    # x-direction
    xhat = np.array([1,0,0]) # an arbitrary direction
    xhat = xhat -zhat*np.dot(xhat,zhat) # Gram-schmit
    xhat /= np.linalg.norm(xhat) 
    
    # y-direction
    yhat = np.cross(zhat, xhat)
    
    
    ## Constructing the grid structure
    xc = np.arange(xmin, xmin+Nx*dx, dx)
    xc = np.sort(np.append(-xc, xc))
    zc = np.arange(z0-Nz_n*dz, z0+(1+Nz_p)*dz, dz)
    
    # y direction is based on the neuron model
    pattern = np.loadtxt(pattern_path, delimiter=' ')
    pattern = (pattern-pattern[::-1])/2  # enforce symmetry (a bug in axon model)
    
    
    if ((alpha==None) & (gamma==None)):
        y_nodes = pattern[:,1]
        x,y,z = np.meshgrid(xc, y_nodes, zc, indexing='xy')
        ref = yhat.copy() # reference direction
        
    else:
        # convert None to zeros
        if alpha==None: 
            alpha=0.
        if gamma==None:
            gamma=0.
        
        rx = R.from_euler('x', alpha, degrees=True).as_dcm()#.as_matrix()
        rz = R.from_euler('z', gamma, degrees=True).as_dcm()#.as_matrix()
        if order=='x_first':
            Rtot = rz @ rx
        else:
            Rtot = rx @ rz

        # Only the pattern are rotated here. The nodes, originally on y-axis,
        # will have a general 3D coordinates after rotation. To braodcast it
        # to all seed centers, we add the x, and z components after making a
        # meshgrid with the xc, rotated_y, and zc. 
        pattern_= (Rtot @ pattern.T).T
        x_nodes = pattern_[:,0]
        y_nodes = pattern_[:,1]
        z_nodes = pattern_[:,2]

        x,y,z = np.meshgrid(xc, y_nodes, zc, indexing='xy')
        x = (x.transpose(1,2,0) + x_nodes).transpose(2,0,1)
        z = (z.transpose(1,2,0) + z_nodes).transpose(2,0,1)
        ref = (Rtot @ yhat.T).T 

    
    ## Constructing the nodes array
    dir_id = [0]*len(x.flatten()) # first direction_id = 0
    k,i,j=np.indices(x.shape)
    nodes = np.stack([x.flatten(), y.flatten(), z.flatten(), dir_id,\
                      i.flatten(), j.flatten(), k.flatten()], axis=-1)

    ## Rovolving
    for n in range(1,n_dirs):
        theta = n/(n_dirs)*np.pi
        Rrev = R.from_euler('z', theta).as_dcm()#.as_matrix()
        revolved = np.dot(np.array([x, y, z]).transpose(1,2,3,0), Rrev.T)
        x_,y_,z_ = revolved.transpose(3,0,1,2)

        dir_id = [n]*len(x_.flatten())
        k_,i_,j_=np.indices(x_.shape)
        nodes_ = np.stack([x_.flatten(), y_.flatten(), z_.flatten(), dir_id,
                           i_.flatten(), j_.flatten(), k_.flatten()],axis=-1)
        nodes = np.vstack((nodes,nodes_))

    ## transferring to the lab coordinates
    A = np.array([xhat,yhat,zhat]).T
    nodes[:,:3] = nodes[:,:3] @ A.T  # rotate
    nodes[:,:3] += origin            # translate
    nodes[:,:3] -= MRI_shift         # shift the positive octant
        
    df_nodes = pd.DataFrame(data=nodes, 
                            columns=['x','y','z','dir_id','i','j','k'])
    df_nodes = df_nodes.set_index(['dir_id','i','j','k']).sort_index()
    df_nodes.to_csv(target_path+'nodes.csv',float_format='%.5f')

    if produce_centers:
        df_axons = df_nodes.groupby(['dir_id','i','j']).mean()
        df_axons.to_csv(target_path+'axons.csv',float_format='%.5f')
    
    # Saving the arrays as csv with correct order
    np.savetxt(target_path+'All_neuron_models.csv', 
               df_nodes[['x','y','z']].values, delimiter=' ')

    if test:
        return nodes, df_nodes, df_axons, xhat, yhat, zhat
